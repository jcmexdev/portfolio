window.i18n_saga = {
  "en": {
    "blog_saga_title": "Mastering Distributed Consistency: Building a Saga Orchestrator in Go",
    "blog_saga_date": "February 2026",
    "blog_saga_read": "8 min read",
    "blog_saga_prob_title": "The Problem: When ACID Isn't Enough",
    "blog_saga_prob_p1": "In the world of monolithic applications, maintaining data consistency is straightforward: we rely on ACID transactions. However, when moving to <strong>Microservices</strong>, the 'T' in ACID (Transactions) becomes a distributed nightmare.",
    "blog_saga_prob_p2": "Imagine an e-commerce flow:",
    "blog_saga_prob_li1": "<strong>Order Service</strong> creates an order.",
    "blog_saga_prob_li2": "<strong>Inventory Service</strong> reserves stock.",
    "blog_saga_prob_li3": "<strong>Payment Service</strong> charges the customer.",
    "blog_saga_prob_p3": "If payment fails, but stock has already been reserved, we face a 'Zombie Reservation'. Traditional <strong>Two-Phase Commit (2PC)</strong> is too slow and creates tight coupling, making it unsuitable for large-scale cloud environments.",
    "blog_saga_sol_title": "The Solution: The Saga Pattern",
    "blog_saga_sol_p1": "To solve this, I implemented the <strong>Saga Pattern</strong>. A Saga is a sequence of local transactions. Each step has a corresponding <strong>Compensating Transaction</strong> to undo changes if a subsequent step fails.",
    "blog_saga_sol_h3": "Why Orchestration over Choreography?",
    "blog_saga_sol_p2": "While Choreography (event-based) is highly decoupled, it can lead to 'Spaghetti Flows' where tracking transaction state becomes almost impossible. I chose <strong>Orchestration</strong>:",
    "blog_saga_sol_li1": "<strong>Centralized Logic</strong>: Easier to maintain and reason about complex business flows.",
    "blog_saga_sol_li2": "<strong>State Visibility</strong>: The Orchestrator knows exactly where the transaction is at any moment.",
    "blog_saga_sol_li3": "<strong>Simplified Debugging</strong>: Error handling is consolidated in one place.",
    "blog_saga_tech_title": "Tech Stack Decisions",
    "blog_saga_tech_grpc_h3": "gRPC: Contract-First Performance",
    "blog_saga_tech_grpc_p1": "Internal communication is based on <strong>gRPC</strong> and <strong>Protocol Buffers</strong>. Compared to REST/JSON, gRPC offers binary serialization and strong typing.",
    "blog_saga_tech_redis_h3": "Redis: The Idempotency Shield",
    "blog_saga_tech_redis_p1": "To achieve 'exactly-once' semantics, each step is protected by an <strong>Idempotency Layer</strong>. Redis acts as a distributed lock, preventing a retry from processing the same payment twice.",
    "blog_saga_challenge_title": "Challenges & Lessons: The Art of Rollback",
    "blog_saga_challenge_p1": "The biggest challenge was handling <strong>Compensating Transactions</strong>. If a step fails, the Orchestrator must trigger rollbacks in <strong>LIFO (Last-In, First-Out)</strong> order.",
    "blog_saga_flow_title": "Transaction Flow",
    "blog_saga_final_title": "Final Thoughts",
    "blog_saga_final_p1": "Building this Saga Orchestrator reinforced a key backend engineering principle: <strong>Consistency is not a given; it's a design decision.</strong>",
    "blog_tag_dist": "Distributed Systems",
    "blog_tag_go": "Go",
    "blog_tag_case": "Case Study",
    "blog_saga_meta_title": "Saga Orchestrator Case Study | Senior Backend Engineer",
    "blog_saga_meta_desc": "Technical deep dive into the Saga Pattern for microservices using Go, gRPC, and Redis."
  },
  "es": {
    "blog_saga_title": "Dominando la Consistencia Distribuida: Construyendo un Orquestador de Sagas en Go",
    "blog_saga_date": "Febrero 2026",
    "blog_saga_read": "8 min de lectura",
    "blog_saga_prob_title": "El Problema: Cuando ACID No es Suficiente",
    "blog_saga_prob_p1": "En el mundo de las aplicaciones monolíticas, mantener la consistencia de los datos es sencillo: confiamos en las transacciones ACID. Sin embargo, al movernos a <strong>Microservicios</strong>, la 'T' de ACID (Transacciones) se convierte en una pesadilla distribuida.",
    "blog_saga_prob_p2": "Imagina un flujo de e-commerce:",
    "blog_saga_prob_li1": "<strong>Order Service</strong> crea una orden.",
    "blog_saga_prob_li2": "<strong>Inventory Service</strong> reserva el stock.",
    "blog_saga_prob_li3": "<strong>Payment Service</strong> realiza el cobro al cliente.",
    "blog_saga_prob_p3": "Si el pago falla, pero el stock ya ha sido reservado, nos enfrentamos a una 'Reserva Zombie'. El tradicional <strong>Two-Phase Commit (2PC)</strong> es demasiado lento y crea un acoplamiento fuerte, lo que lo hace inadecuado para entornos de nube de gran escala.",
    "blog_saga_sol_title": "La Solución: El Patrón Saga",
    "blog_saga_sol_p1": "Para solucionar esto, implementé el <strong>Saga Pattern</strong>. Una Saga es una secuencia de transacciones locales. Cada paso tiene una <strong>Transacción de Compensación</strong> correspondiente para deshacer los cambios si un paso posterior falla.",
    "blog_saga_sol_h3": "¿Por qué Orquestación sobre Coreografía?",
    "blog_saga_sol_p2": "Si bien la Coreografía (basada en eventos) es altamente desacoplada, puede llevar a 'Flujos Spaghetti' donde rastrear el estado de una transacción se vuelve casi imposible. Elegí <strong>Orquestación</strong>:",
    "blog_saga_sol_li1": "<strong>Lógica centralizada</strong>: Más fácil de mantener y razonar sobre flujos de negocio complejos.",
    "blog_saga_sol_li2": "<strong>Visibilidad del estado</strong>: El Orquestador sabe exactamente dónde está la transacción en cualquier momento.",
    "blog_saga_sol_li3": "<strong>Debugging simplificado</strong>: El manejo de errores está consolidado en un solo lugar.",
    "blog_saga_tech_title": "Decisiones del Tech Stack",
    "blog_saga_tech_grpc_h3": "gRPC: Rendimiento Contract-First",
    "blog_saga_tech_grpc_p1": "La comunicación interna se basa en <strong>gRPC</strong> y <strong>Protocol Buffers</strong>. Comparado con REST/JSON, gRPC ofrece serialización binaria y un tipado fuerte.",
    "blog_saga_tech_redis_h3": "Redis: El Escudo de Idempotencia",
    "blog_saga_tech_redis_p1": "Para lograr semántica de 'exactamente una vez', cada paso está protegido por una <strong>Capa de Idempotencia</strong>. Redis actúa como un bloqueo distribuido, evitando que un reintento procese el mismo pago dos veces.",
    "blog_saga_challenge_title": "Retos y Lecciones: El Arte del Rollback",
    "blog_saga_challenge_p1": "El mayor desafío fue manejar las <strong>Transacciones de Compensación</strong>. Si un paso falla, el Orquestador debe activar los rollbacks en orden <strong>LIFO (Last-In, First-Out)</strong>.",
    "blog_saga_flow_title": "Flujo de Transacción",
    "blog_saga_final_title": "Reflexiones Finales",
    "blog_saga_final_p1": "Construir este Orquestador de Sagas reforzó un principio clave de la ingeniería de backend: <strong>La consistencia no es algo dado; es una decisión de diseño.</strong>",
    "blog_tag_dist": "Sistemas Distribuidos",
    "blog_tag_go": "Go",
    "blog_tag_case": "Caso de Estudio",
    "blog_saga_meta_title": "Caso de Estudio: Orquestador de Sagas | Senior Backend Engineer",
    "blog_saga_meta_desc": "Análisis técnico profundo del Patrón Saga para microservicios usando Go, gRPC y Redis."
  }
};
